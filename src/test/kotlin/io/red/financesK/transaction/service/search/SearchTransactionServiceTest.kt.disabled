package io.red.financesK.transaction.service.search

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import io.red.financesK.transaction.controller.request.SearchTransactionFilter
import io.red.financesK.transaction.controller.response.AmountIncomeExpenseResponse
import io.red.financesK.transaction.controller.response.TransactionResponse
import io.red.financesK.transaction.enums.PaymentStatus
import io.red.financesK.transaction.enums.SortDirection
import io.red.financesK.transaction.enums.TransactionSortField
import io.red.financesK.transaction.enums.TransactionType
import io.red.financesK.transaction.model.Transaction
import io.red.financesK.transaction.repository.TransactionRepository
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import org.springframework.data.domain.Page
import java.math.BigDecimal
import java.time.LocalDate

class SearchTransactionServiceTest {

    private lateinit var transactionRepository: TransactionRepository
    private lateinit var searchTransactionService: SearchTransactionService

    @BeforeEach
    fun setUp() {
        transactionRepository = mockk()
        searchTransactionService = SearchTransactionService(transactionRepository)
    }

    @Test
    @DisplayName("Deve calcular balance de receitas e despesas com sucesso")
    fun `should calculate income expense balance successfully`() {
        // Given
        val userId = 1
        val status = PaymentStatus.PAID
        val startDate = LocalDate.of(2025, 1, 1)
        val endDate = LocalDate.of(2025, 1, 31)
        val mockResponse = AmountIncomeExpenseResponse(
            totalIncome = BigDecimal("1000.00"),
            totalExpense = BigDecimal("500.00"),
            balance = BigDecimal("500.00")
        )

        every {
            transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate)
        } returns mockResponse

        // When
        val result = searchTransactionService.getIncomeExpenseBalance(userId, status, startDate, endDate)

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("1000.00"), result.totalIncome)
        assertEquals(BigDecimal("500.00"), result.totalExpense)
        assertEquals(BigDecimal("500.00"), result.balance)
        assertEquals("R$", result.currency)

        verify { transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate) }
    }

    @Test
    @DisplayName("Deve calcular balance com status nulo")
    fun `should calculate balance with null status`() {
        // Given
        val userId = 1
        val startDate = LocalDate.of(2025, 1, 1)
        val endDate = LocalDate.of(2025, 1, 31)
        val mockResponse = AmountIncomeExpenseResponse(
            totalIncome = BigDecimal("750.00"),
            totalExpense = BigDecimal("250.00"),
            balance = BigDecimal("500.00")
        )

        every {
            transactionRepository.getIncomeExpenseBalance(userId, null, startDate, endDate)
        } returns mockResponse

        // When
        val result = searchTransactionService.getIncomeExpenseBalance(userId, null, startDate, endDate)

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("750.00"), result.totalIncome)
        assertEquals(BigDecimal("250.00"), result.totalExpense)
        assertEquals(BigDecimal("500.00"), result.balance)

        verify { transactionRepository.getIncomeExpenseBalance(userId, null, startDate, endDate) }
    }

    @Test
    @DisplayName("Deve somar valores por tipo INCOME corretamente")
    fun `should sum amounts by INCOME type correctly`() {
        // Given
        val userId = 1
        val type = "INCOME"
        val status = "PAID"
        val startDate = "2025-01-01"
        val endDate = "2025-01-31"
        val incomeAmount = 1500

        every {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PAID,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        } returns incomeAmount

        // When
        val result = searchTransactionService.sumAmountByUserIdAndTypeAndDateRange(
            userId, type, status, startDate, endDate
        )

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("15.00"), result.totalIncome) // ConvertMoneyUtils converte centavos para reais
        assertEquals(BigDecimal("0.00"), result.totalExpense)
        assertEquals(BigDecimal("15.00"), result.balance)

        verify {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PAID,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        }
    }

    @Test
    @DisplayName("Deve somar valores por tipo EXPENSE corretamente")
    fun `should sum amounts by EXPENSE type correctly`() {
        // Given
        val userId = 1
        val type = "EXPENSE"
        val status = "PAID"
        val startDate = "2025-01-01"
        val endDate = "2025-01-31"
        val expenseAmount = 800

        every {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.EXPENSE, PaymentStatus.PAID,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        } returns expenseAmount

        // When
        val result = searchTransactionService.sumAmountByUserIdAndTypeAndDateRange(
            userId, type, status, startDate, endDate
        )

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("0.00"), result.totalIncome)
        assertEquals(BigDecimal("8.00"), result.totalExpense) // ConvertMoneyUtils converte centavos para reais
        assertEquals(BigDecimal("-8.00"), result.balance)

        verify {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.EXPENSE, PaymentStatus.PAID,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        }
    }

    @Test
    @DisplayName("Deve lidar com valores nulos do repositório")
    fun `should handle null values from repository`() {
        // Given
        val userId = 1
        val type = "INCOME"
        val status = "PENDING"
        val startDate = "2025-01-01"
        val endDate = "2025-01-31"

        every {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PENDING,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        } returns null

        // When
        val result = searchTransactionService.sumAmountByUserIdAndTypeAndDateRange(
            userId, type, status, startDate, endDate
        )

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("0.00"), result.totalIncome)
        assertEquals(BigDecimal("0.00"), result.totalExpense)
        assertEquals(BigDecimal("0.00"), result.balance)

        verify {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PENDING,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        }
    }

    @Test
    @DisplayName("Deve calcular balance com zero receitas e despesas")
    fun `should calculate balance with zero income and expenses`() {
        // Given
        val userId = 1
        val status = PaymentStatus.PAID
        val startDate = LocalDate.of(2025, 1, 1)
        val endDate = LocalDate.of(2025, 1, 31)
        val mockResponse = AmountIncomeExpenseResponse(
            totalIncome = BigDecimal("0.00"),
            totalExpense = BigDecimal("0.00"),
            balance = BigDecimal("0.00")
        )

        every {
            transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate)
        } returns mockResponse

        // When
        val result = searchTransactionService.getIncomeExpenseBalance(userId, status, startDate, endDate)

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("0.00"), result.totalIncome)
        assertEquals(BigDecimal("0.00"), result.totalExpense)
        assertEquals(BigDecimal("0.00"), result.balance)

        verify { transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate) }
    }

    @Test
    @DisplayName("Deve validar conversão de datas string para LocalDate")
    fun `should validate string to LocalDate conversion`() {
        // Given
        val userId = 1
        val type = "INCOME"
        val status = "PAID"
        val startDate = "2025-12-01"
        val endDate = "2025-12-31"
        val incomeAmount = 2000

        every {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PAID,
                LocalDate.of(2025, 12, 1), LocalDate.of(2025, 12, 31)
            )
        } returns incomeAmount

        // When
        val result = searchTransactionService.sumAmountByUserIdAndTypeAndDateRange(
            userId, type, status, startDate, endDate
        )

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("20.00"), result.totalIncome)

        verify {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.INCOME, PaymentStatus.PAID,
                LocalDate.of(2025, 12, 1), LocalDate.of(2025, 12, 31)
            )
        }
    }

    @Test
    @DisplayName("Deve validar conversão de enums string para tipos corretos")
    fun `should validate string to enum conversion`() {
        // Given
        val userId = 1
        val type = "EXPENSE"
        val status = "PENDING"
        val startDate = "2025-01-01"
        val endDate = "2025-01-31"
        val expenseAmount = 1200

        every {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.EXPENSE, PaymentStatus.PENDING,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        } returns expenseAmount

        // When
        val result = searchTransactionService.sumAmountByUserIdAndTypeAndDateRange(
            userId, type, status, startDate, endDate
        )

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("0.00"), result.totalIncome)
        assertEquals(BigDecimal("12.00"), result.totalExpense)
        assertEquals(BigDecimal("-12.00"), result.balance)

        verify {
            transactionRepository.sumAmountByUserIdAndTypeAndDateRange(
                userId, TransactionType.EXPENSE, PaymentStatus.PENDING,
                LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31)
            )
        }
    }

    @Test
    @DisplayName("Deve calcular balance negativo quando despesas maiores que receitas")
    fun `should calculate negative balance when expenses greater than income`() {
        // Given
        val userId = 1
        val status = PaymentStatus.PAID
        val startDate = LocalDate.of(2025, 1, 1)
        val endDate = LocalDate.of(2025, 1, 31)
        val mockResponse = AmountIncomeExpenseResponse(
            totalIncome = BigDecimal("300.00"),
            totalExpense = BigDecimal("800.00"),
            balance = BigDecimal("-500.00")
        )

        every {
            transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate)
        } returns mockResponse

        // When
        val result = searchTransactionService.getIncomeExpenseBalance(userId, status, startDate, endDate)

        // Then
        assertNotNull(result)
        assertEquals(BigDecimal("300.00"), result.totalIncome)
        assertEquals(BigDecimal("800.00"), result.totalExpense)
        assertEquals(BigDecimal("-500.00"), result.balance)

        verify { transactionRepository.getIncomeExpenseBalance(userId, status, startDate, endDate) }
    }

    @Test
    @DisplayName("Deve buscar transações paginadas com filtros básicos")
    fun `should search transactions paginated with basic filters`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31)
        )
        val page = 0
        val size = 10
        val sortField = TransactionSortField.DUE_DATE
        val sortDirection = SortDirection.DESC

        val mockTransaction = mockk<Transaction> {
            every { id } returns 1
            every { description } returns "Teste"
            every { amount } returns 10000
            every { type } returns TransactionType.EXPENSE
            every { categoryId } returns mockk { every { id } returns 1 }
            every { dueDate } returns LocalDate.of(2025, 1, 15)
            every { createdAt } returns LocalDate.of(2025, 1, 15).atStartOfDay()
            every { notes } returns "Nota teste"
            every { recurrencePattern } returns null
            every { installmentInfo } returns null
            every { userId } returns mockk { every { id } returns 1 }
        }

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 1L
            every { totalPages } returns 1
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 1L
                every { totalPages } returns 1
                every { content } returns listOf(
                    TransactionResponse(
                        id = 1,
                        description = "Teste",
                        amount = BigDecimal("100.00"),
                        type = "EXPENSE",
                        categoryId = 1,
                        transactionDate = LocalDate.of(2025, 1, 15),
                        createdAt = LocalDate.of(2025, 1, 15).atStartOfDay(),
                        notes = "Nota teste",
                        recurrencePattern = null,
                        installmentInfo = null,
                        userId = 1
                    )
                )
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        } returns mockPage

        // When
        val result = searchTransactionService.searchTransactionsPaginated(
            filter, page, size, sortField, sortDirection
        )

        // Then
        assertNotNull(result)
        assertEquals(1L, result.totalElements)
        assertEquals(1, result.totalPages)

        verify {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        }
    }

    @Test
    @DisplayName("Deve buscar transações com filtros de tipo INCOME")
    fun `should search transactions with INCOME type filter`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            type = TransactionType.INCOME
        )

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 5L
            every { totalPages } returns 1
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 5L
                every { totalPages } returns 1
                every { content } returns emptyList()
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = TransactionType.INCOME,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        } returns mockPage

        // When
        val result = searchTransactionService.searchTransactionsPaginated(filter, 0, 20)

        // Then
        assertNotNull(result)
        assertEquals(5L, result.totalElements)

        verify {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = TransactionType.INCOME,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        }
    }

    @Test
    @DisplayName("Deve buscar transações recorrentes")
    fun `should search recurring transactions`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            isRecurring = true
        )

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 3L
            every { totalPages } returns 1
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 3L
                every { totalPages } returns 1
                every { content } returns emptyList()
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = true,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        } returns mockPage

        // When
        val result = searchTransactionService.searchTransactionsPaginated(filter, 0, 20)

        // Then
        assertNotNull(result)
        assertEquals(3L, result.totalElements)

        verify {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = true,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        }
    }

    @Test
    @DisplayName("Deve buscar transações parceladas")
    fun `should search installment transactions`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            hasInstallments = true
        )

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 2L
            every { totalPages } returns 1
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 2L
                every { totalPages } returns 1
                every { content } returns emptyList()
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = true,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        } returns mockPage

        // When
        val result = searchTransactionService.searchTransactionsPaginated(filter, 0, 20)

        // Then
        assertNotNull(result)
        assertEquals(2L, result.totalElements)

        verify {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = true,
                description = null,
                minAmount = null,
                maxAmount = null,
                pageable = any()
            )
        }
    }

    @Test
    @DisplayName("Deve contar transações com filtros")
    fun `should count transactions with filters`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            type = TransactionType.EXPENSE,
            status = PaymentStatus.PAID
        )

        every {
            transactionRepository.countTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = TransactionType.EXPENSE,
                status = PaymentStatus.PAID,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null
            )
        } returns 15L

        // When
        val result = searchTransactionService.searchTransactionsCount(filter)

        // Then
        assertEquals(15L, result)

        verify {
            transactionRepository.countTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = TransactionType.EXPENSE,
                status = PaymentStatus.PAID,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = null,
                maxAmount = null
            )
        }
    }

    @Test
    @DisplayName("Deve buscar com filtros de valor mínimo e máximo")
    fun `should search with min and max amount filters`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            minAmount = 5000, // R$ 50,00
            maxAmount = 20000 // R$ 200,00
        )

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 8L
            every { totalPages } returns 1
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 8L
                every { totalPages } returns 1
                every { content } returns emptyList()
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = 5000,
                maxAmount = 20000,
                pageable = any()
            )
        } returns mockPage

        // When
        val result = searchTransactionService.searchTransactionsPaginated(filter, 0, 20)

        // Then
        assertNotNull(result)
        assertEquals(8L, result.totalElements)

        verify {
            transactionRepository.findTransactionsByFilters(
                userId = 1,
                startDate = LocalDate.of(2025, 1, 1),
                endDate = LocalDate.of(2025, 1, 31),
                type = null,
                status = null,
                categoryId = null,
                isRecurring = null,
                hasInstallments = null,
                description = null,
                minAmount = 5000,
                maxAmount = 20000,
                pageable = any()
            )
        }
    }

    @Test
    @DisplayName("Deve validar ordenação por diferentes campos")
    fun `should validate sorting by different fields`() {
        // Given
        val filter = SearchTransactionFilter(
            userId = 1,
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31)
        )

        val mockPage = mockk<Page<Transaction>> {
            every { totalElements } returns 0L
            every { totalPages } returns 0
            every { map<TransactionResponse>(any()) } returns mockk {
                every { totalElements } returns 0L
                every { totalPages } returns 0
                every { content } returns emptyList()
            }
        }

        every {
            transactionRepository.findTransactionsByFilters(any(), any(), any(), any(), any(), any(), any(), any(), any(), any(), any(), any())
        } returns mockPage

        // When & Then - Testar diferentes campos de ordenação
        val sortFields = listOf(
            TransactionSortField.AMOUNT,
            TransactionSortField.TYPE,
            TransactionSortField.CATEGORY,
            TransactionSortField.DUE_DATE
        )

        sortFields.forEach { sortField ->
            val result = searchTransactionService.searchTransactionsPaginated(
                filter, 0, 20, sortField, SortDirection.ASC
            )
            assertNotNull(result)
        }

        verify(exactly = sortFields.size) {
            transactionRepository.findTransactionsByFilters(any(), any(), any(), any(), any(), any(), any(), any(), any(), any(), any(), any())
        }
    }
}
