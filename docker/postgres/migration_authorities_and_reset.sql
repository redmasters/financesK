-- =====================================================
-- SCRIPT DE MIGRAÇÃO PARA PRODUÇÃO
-- Data: 2025-10-03
-- Descrição: Adiciona sistema de authorities e tabelas de reset de senha
-- =====================================================

-- Início da transação para garantir atomicidade
BEGIN;

-- =====================================================
-- 1. ADICIONAR TABELA DE RESET DE SENHA
-- =====================================================

-- Criar tabela para armazenar tokens de redefinição de senha
CREATE TABLE IF NOT EXISTS tbl_password_reset_token (
    reset_token_id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    reset_token    VARCHAR(255),
    user_id        INTEGER                                 NOT NULL,
    expiry_date    TIMESTAMP WITHOUT TIME ZONE,
    CONSTRAINT pk_tbl_password_reset_token PRIMARY KEY (reset_token_id)
);

-- Adicionar foreign key para user_id
ALTER TABLE tbl_password_reset_token
    ADD CONSTRAINT FK_TBL_PASSWORD_RESET_TOKEN_ON_USER
    FOREIGN KEY (user_id) REFERENCES tbl_app_user (id) ON DELETE CASCADE;

-- Criar índice para performance
CREATE INDEX IF NOT EXISTS idx_password_reset_token_user ON tbl_password_reset_token (user_id);
CREATE INDEX IF NOT EXISTS idx_password_reset_token_token ON tbl_password_reset_token (reset_token);
CREATE INDEX IF NOT EXISTS idx_password_reset_token_expiry ON tbl_password_reset_token (expiry_date);

-- Comentários para documentação
COMMENT ON TABLE tbl_password_reset_token IS 'Tabela para armazenar tokens de redefinição de senha dos usuários';
COMMENT ON COLUMN tbl_password_reset_token.reset_token_id IS 'Identificador único do token de redefinição';
COMMENT ON COLUMN tbl_password_reset_token.reset_token IS 'Token de redefinição de senha (string única e segura)';
COMMENT ON COLUMN tbl_password_reset_token.user_id IS 'ID do usuário associado ao token de redefinição';
COMMENT ON COLUMN tbl_password_reset_token.expiry_date IS 'Data e hora de expiração do token';

-- =====================================================
-- 2. ADICIONAR SISTEMA DE AUTHORITIES
-- =====================================================

-- Criar tabela para armazenar as authorities dos usuários
CREATE TABLE IF NOT EXISTS tbl_user_authorities (
    user_id   INTEGER     NOT NULL,
    authority VARCHAR(50) NOT NULL,
    CONSTRAINT pk_user_authorities PRIMARY KEY (user_id, authority),
    CONSTRAINT fk_user_authorities_user_id
        FOREIGN KEY (user_id) REFERENCES tbl_app_user (id) ON DELETE CASCADE
);

-- Criar índices para melhorar performance das consultas
CREATE INDEX IF NOT EXISTS idx_user_authorities_user_id ON tbl_user_authorities (user_id);
CREATE INDEX IF NOT EXISTS idx_user_authorities_authority ON tbl_user_authorities (authority);

-- Comentários para documentação
COMMENT ON TABLE tbl_user_authorities IS 'Tabela para armazenar as authorities/roles dos usuários do sistema';
COMMENT ON COLUMN tbl_user_authorities.user_id IS 'ID do usuário (referência para tbl_app_user)';
COMMENT ON COLUMN tbl_user_authorities.authority IS 'Authority/Role do usuário: USER, ADMIN, CHANGE_PASSWORD_PRIVILEGE';

-- =====================================================
-- 3. INSERIR AUTHORITY PADRÃO PARA USUÁRIOS EXISTENTES
-- =====================================================

-- Inserir authority USER para todos os usuários existentes que não têm authorities
INSERT INTO tbl_user_authorities (user_id, authority)
SELECT id, 'USER'
FROM tbl_app_user
WHERE id NOT IN (
    SELECT DISTINCT user_id
    FROM tbl_user_authorities
    WHERE user_id IS NOT NULL
);

-- =====================================================
-- 4. ADICIONAR COMENTÁRIOS FALTANTES (se necessário)
-- =====================================================

-- Adicionar comentário para coluna updated_at da tbl_app_user se não existir
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_description d
        JOIN pg_class c ON c.oid = d.objoid
        JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = d.objsubid
        WHERE c.relname = 'tbl_app_user' AND a.attname = 'updated_at'
    ) THEN
        COMMENT ON COLUMN tbl_app_user.updated_at IS 'Data e hora da última atualização dos dados do usuário';
    END IF;
END $$;

-- Adicionar comentário para coluna password_salt da tbl_app_user se não existir
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_description d
        JOIN pg_class c ON c.oid = d.objoid
        JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = d.objsubid
        WHERE c.relname = 'tbl_app_user' AND a.attname = 'password_salt'
    ) THEN
        COMMENT ON COLUMN tbl_app_user.password_salt IS 'Salt usado para aumentar a segurança do hash da senha';
    END IF;
END $$;

-- =====================================================
-- 5. VALIDAÇÕES E CONSTRAINTS ADICIONAIS
-- =====================================================

-- Adicionar constraint para garantir que authorities sejam válidas
ALTER TABLE tbl_user_authorities
ADD CONSTRAINT chk_authority_values
CHECK (authority IN ('USER', 'ADMIN', 'CHANGE_PASSWORD_PRIVILEGE'));

-- Adicionar constraint para garantir que tokens de reset tenham tamanho mínimo
ALTER TABLE tbl_password_reset_token
ADD CONSTRAINT chk_reset_token_length
CHECK (LENGTH(reset_token) >= 10);

-- =====================================================
-- 6. CRIAR USUÁRIO ADMINISTRADOR INICIAL (OPCIONAL)
-- =====================================================

-- Comentário: Descomente as linhas abaixo para criar um usuário admin inicial
-- Certifique-se de alterar a senha antes de executar em produção

/*
-- Inserir usuário administrador inicial (APENAS SE NÃO EXISTIR)
DO $$
DECLARE
    admin_user_id INTEGER;
BEGIN
    -- Verificar se já existe um usuário admin
    IF NOT EXISTS (
        SELECT 1 FROM tbl_app_user
        WHERE username = 'admin' OR email = 'admin@financesK.com'
    ) THEN
        -- Inserir usuário admin
        INSERT INTO tbl_app_user (
            username,
            email,
            password_hash,
            password_salt,
            path_avatar,
            created_at
        ) VALUES (
            'admin',
            'admin@financesK.com',
            '$2a$10$example.hash.here', -- ALTERE ESTA SENHA!
            'example_salt_here',      -- ALTERE ESTE SALT!
            'default-admin-avatar.png',
            NOW()
        ) RETURNING id INTO admin_user_id;

        -- Adicionar authorities de USER e ADMIN
        INSERT INTO tbl_user_authorities (user_id, authority) VALUES
            (admin_user_id, 'USER'),
            (admin_user_id, 'ADMIN');

        RAISE NOTICE 'Usuário administrador criado com ID: %', admin_user_id;
    ELSE
        RAISE NOTICE 'Usuário administrador já existe, pulando criação';
    END IF;
END $$;
*/

-- =====================================================
-- 7. VERIFICAÇÕES FINAIS
-- =====================================================

-- Verificar se todas as tabelas foram criadas corretamente
DO $$
BEGIN
    -- Verificar tbl_password_reset_token
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables
                   WHERE table_name = 'tbl_password_reset_token') THEN
        RAISE EXCEPTION 'Erro: Tabela tbl_password_reset_token não foi criada';
    END IF;

    -- Verificar tbl_user_authorities
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables
                   WHERE table_name = 'tbl_user_authorities') THEN
        RAISE EXCEPTION 'Erro: Tabela tbl_user_authorities não foi criada';
    END IF;

    RAISE NOTICE 'Migração concluída com sucesso!';
    RAISE NOTICE 'Tabelas criadas: tbl_password_reset_token, tbl_user_authorities';
    RAISE NOTICE 'Authorities adicionadas para % usuários existentes',
        (SELECT COUNT(*) FROM tbl_user_authorities WHERE authority = 'USER');
END $$;

-- Commit da transação
COMMIT;

-- =====================================================
-- INFORMAÇÕES IMPORTANTES PARA O DEPLOY
-- =====================================================

/*
INSTRUÇÕES PARA APLICAR ESTA MIGRAÇÃO:

1. BACKUP: Sempre faça backup do banco antes de aplicar
   pg_dump -h localhost -U usuario -d financesK > backup_pre_migration.sql

2. APLICAR MIGRAÇÃO:
   psql -h localhost -U usuario -d financesK -f migration_authorities_and_reset.sql

3. VERIFICAR RESULTADOS:
   - Confirme que as tabelas foram criadas
   - Verifique se os usuários existentes receberam authority USER
   - Teste o login e funcionalidades básicas

4. ROLLBACK (se necessário):
   - DROP TABLE tbl_user_authorities;
   - DROP TABLE tbl_password_reset_token;

AUTHORITIES DISPONÍVEIS APÓS A MIGRAÇÃO:
- USER: Usuários comuns (padrão para todos)
- ADMIN: Administradores do sistema
- CHANGE_PASSWORD_PRIVILEGE: Privilégio temporário para reset de senha

ENDPOINTS AFETADOS:
- Todos os endpoints agora verificam authorities
- Novos endpoints para gerenciar authorities em /api/v1/authorities
- Reset de senha funciona automaticamente com privilégios temporários
*/
